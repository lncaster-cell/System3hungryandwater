# Аудит всех механизмов (NWScript)

Дата: 2026-02-15
Объект аудита: `nwscript/system_core.nss`, `nwscript/camp_system.nss`, `nwscript/travel_system.nss`, `nwscript/encounter_system.nss`, `nwscript/trade_system.nss`.

## Краткий итог

- Архитектура в целом соответствует заявленной цели «лёгкой» событийной модели: нет постоянных тиков по карте, операции в основном `O(1)`/`O(P)`.
- Критичных проблем, которые гарантированно ломают базовый happy-path, не выявлено.
- Найдено **2 проблемы высокого приоритета** (повторные срабатывания встречи в одном окне; отсутствие защиты от переполнения при расчёте стоимости покупки).
- Найдено **3 проблемы среднего приоритета** (перезапуск путешествия во время активного маршрута; отсутствие валидации зарегистрированности городов; риск переполнения времени пути).
- Дополнительно отмечены улучшения устойчивости и observability.

## Охват и метод

1. Ручной code review всех NWScript-модулей.
2. Проверка корректности инвариантов состояния между системами (camp/travel/encounter/trade).
3. Проверка целочисленной арифметики на переполнение и граничные условия.

---

## 1) Базовый слой (`system_core.nss`)

### Что хорошо
- Централизованы ключи локальных переменных и генераторы ключей.
- Есть базовые helper-функции для целочисленной работы.

### Риски
- `AbsInt` не обрабатывает крайний случай минимального int (`INT_MIN`), где `-INT_MIN` в 32-bit переполняется.
  - При текущем коде это маловероятно на типичных игровых координатах, но как библиотечный helper это «скрытая мина».

### Рекомендации
- Добавить безопасный вариант `AbsIntSafe` или saturating-логику для минимального int.

---

## 2) Лагерь (`camp_system.nss`)

### Что хорошо
- Переключение лагеря и применение множителя активности сделаны линейно по партии и только по событию.
- Нет фоновых пересчётов.

### Риски
- Доверие к `KEY_PARTY_SIZE`: если размер не синхронизирован со слотами, часть участников может остаться с устаревшим multiplier.

### Рекомендации
- В точке обновления состава партии обеспечивать строгую синхронизацию `KEY_PARTY_SIZE` и `PARTY_MEMBER_i`.

---

## 3) Путешествия (`travel_system.nss`)

### Найденные проблемы

#### M-1: Можно повторно вызвать `StartTravel` во время активного маршрута (средний)
- В `StartTravel` нет раннего отказа при `KEY_TRAVEL_ACTIVE == TRUE`.
- Риск: перезапись состояния маршрута в середине пути (источник, цель, seed, timestamps).

**Рекомендация:**
- Добавить guard: если путешествие активно — возвращать `FALSE`.

#### M-2: Нет проверки, что города зарегистрированы (средний)
- `ComputeTravelDurationMs` читает координаты по ключам, но при отсутствии регистрации получит `0/0`.
- Риск: «телепортационные»/ложные расчёты времени до неинициализированного города.

**Рекомендация:**
- Хранить флаг регистрации города (`CITY_EXISTS_<id>`) и валидировать `from/to` перед стартом.

#### M-3: Риск переполнения в `nDistance * 60000` (средний)
- При больших координатах произведение может выйти за диапазон int.

**Рекомендация:**
- Делить до умножения где возможно, либо ограничить входные координаты/дистанцию, либо использовать безопасный helper с проверкой диапазона.

### Что хорошо
- Ленивая timestamp-модель без тиков.
- Ясная очистка travel-state в `ResolveArrival`.

---

## 4) Встречи (`encounter_system.nss`)

### Найденные проблемы

#### H-1: Повторное срабатывание встречи в одном и том же окне времени (высокий)
- `ShouldTriggerEncounter` не проверяет, что текущий bucket уже был обработан.
- При многократном вызове в пределах одного `ENCOUNTER_WINDOW_MS` возможны повторные `TRUE` и повторная запись encounter-state.

**Рекомендация:**
- Вести `KEY_ENCOUNTER_LAST_BUCKET` и возвращать `FALSE`, если bucket уже обработан.
- Альтернатива: использовать `KEY_ENCOUNTER_LAST_MS` + сравнение `lastMs / window == currentBucket`.

#### L-1: Вероятностная модель не зависит от длины маршрута/состояния группы (низкий)
- Сейчас шанс фиксированный (`ENCOUNTER_CHANCE_MILLI = 180`).

**Рекомендация:**
- При необходимости геймдизайна добавить модификаторы от биома, погоды, состава группы и т.п. без усложнения алгоритма.

### Что хорошо
- Детерминированность через seed + route + bucket.
- Дешёвая O(1)-проверка.

---

## 5) Торговля (`trade_system.nss`)

### Найденные проблемы

#### H-2: Нет защиты от переполнения в `nTotal = nPrice * nQty` (высокий)
- При больших значениях возможен overflow с некорректным балансом.
- В худшем случае это может дать отрицательный/заниженный total и обойти проверку средств.

**Рекомендация:**
- До умножения проверять `nQty > MAX_INT / nPrice`.
- При переполнении — возвращать `-1`.

#### L-2: Нет верхней границы для складского остатка и балансов (низкий)
- `ClampMinInt` ограничивает только снизу.

**Рекомендация:**
- Ввести saturating cap для значений экономики (например, `ECON_MAX`).

### Что хорошо
- Транзакция одной строки покупки реализована последовательно и атомарно в рамках скриптового вызова.
- Валидация входа и остатков присутствует.

---

## Приоритетный план исправлений

1. **Срочно (P1):**
   - Добавить анти-дубликат в `ShouldTriggerEncounter` (bucket guard).
   - Добавить overflow-check в `BuyOneLine` перед умножением `price * qty`.
2. **Далее (P2):**
   - Запретить `StartTravel` при активном маршруте.
   - Валидировать зарегистрированность городов.
   - Защитить расчёт длительности от переполнения.
3. **Улучшения (P3):**
   - Saturating-границы для экономических и координатных параметров.
   - Усилить инварианты состава партии/лагеря.

## Заключение

Текущая реализация демонстрирует правильный вектор для производительного NWScript (событийность, integer-only, отсутствие глобального тика). Основные доработки касаются не архитектуры, а **защиты от граничных условий и арифметического переполнения**. После закрытия P1/P2 система будет существенно устойчивее без заметного роста runtime-стоимости.
