# Аудит производительности и логики NWScript-механик

Дата: 2026-02-15  
Область: `camp_system`, `travel_system`, `encounter_system`, `trade_system`, `system_core`.

## Что исправлено в коде

1. **Устранён дубликат-триггер встреч в том же тайм-окне**:
   - добавлен ключ `KEY_ENCOUNTER_LAST_BUCKET`;
   - проверка текущего bucket вынесена в `ShouldTriggerEncounter` до roll;
   - bucket записывается при успешном триггере.
2. **Сброс encounter-маркеров при старте и завершении путешествия**:
   - чтобы состояние старого маршрута не влияло на новый.

Эти изменения уменьшают лишние вычисления (повторные роллы в одном окне) и исключают повторный запуск тяжёлой encounter-логики в hot-path.

---

## Текущая оценка логики и быстродействия

### 1) `camp_system`
- **Сложность:** `O(P)` по размеру партии, событийная модель, без фонового цикла.
- **Плюсы:** минимальные операции, локальные int/set только по событию переключения лагеря.
- **Риски:** если `KEY_PARTY_SIZE` не синхронизирован с реальными слотами, часть участников не обновится.
- **Альтернатива:** ввести `PARTY_REVISION` и валидировать слоты при изменении состава, а не в момент camp-toggle.

### 2) `travel_system`
- **Сложность:** `O(1)` на старт/финиш, без per-tick.
- **Плюсы:** timestamp-модель и ранние guard'ы дешёвые по CPU.
- **Риски:** Manhattan distance (`|dx| + |dy|`) может быть грубым приближением (геймдизайн), но вычислительно дешевле евклидовой метрики.
- **Альтернатива производительности:** оставить Manhattan как fast-path, а для особых маршрутов хранить precomputed edge-cost (lookup в `O(1)` без runtime-арифметики).

### 3) `encounter_system`
- **Сложность:** `O(1)` на проверку окна.
- **Плюсы:** детерминированный hash-roll по `(seed, route, bucket)`.
- **Исправленный дефект:** повторное срабатывание в одном bucket устранено через `KEY_ENCOUNTER_LAST_BUCKET`.
- **Альтернатива:** если нужен ещё более дешёвый путь, можно кешировать `nRoute` на старте путешествия в отдельный local int и не вычислять fingerprint при каждой проверке.

### 4) `trade_system`
- **Сложность:** `O(1)` на одну строку покупки, integer-only.
- **Плюсы:** есть проверки overflow для `price*qty` и `lot*count`, атомарный commit в рамках одного скриптового вызова.
- **Риски:** UI-сборка строк в циклах может быть затратной при больших `nCount` (строковые конкатенации в NWScript).
- **Альтернатива производительности:**
  - paginated GUI (например, по 20 строк);
  - обновлять только dirty-строки вместо полного rebuild.

### 5) `system_core`
- **Плюсы:** централизованные ключи и saturating arithmetic helper.
- **Альтернатива:** общий helper `SafeMulInt(a,b,out)` для унификации проверок переполнения и уменьшения дублирования проверок в торговле/путешествии.

---

## Приоритетный roadmap (в фокусе быстродействие)

1. **P1 (сделано):** bucket-guard для encounter + сброс маркеров при смене маршрута.
2. **P2:** кеш route fingerprint на время путешествия (минус несколько операций и вызовов на каждый encounter-check).
3. **P2:** пагинация trade GUI и частичное обновление строк.
4. **P3:** инварианты party-size/slots через revision-модель.

## Итог

Архитектура уже оптимальна для NWScript-ограничений: событийность, integer-only, отсутствие глобального тика. После внесённого bucket-guard путь проверки встреч стал устойчивее и дешевле при многократных вызовах в одном окне времени.
