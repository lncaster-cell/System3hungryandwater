# Архитектура механики голода и жажды

## Цели
- Поддерживать голод/жажду для игрока и членов партии.
- Минимизировать нагрузку на CPU и серверный тик.
- Сохранить детерминированность и простую сериализацию.

## Оптимизационная модель

### 1) Ленивый (lazy) пересчёт вместо постоянного тика
Вместо обновления каждого персонажа каждый тик, у каждой сущности хранится `last_update_ms`.
Пересчёт выполняется только когда:
- нужен снапшот для UI/сети;
- персонаж ест/пьёт;
- меняется активность (бег/бой/покой).

Это убирает `O(N)` работу на каждый серверный тик и переводит её в `O(K)` по числу реально затронутых сущностей.

### 2) Fixed-point арифметика
Все значения хранятся в milli-единицах (`100.000` = `100000`).
Плюсы:
- нет дрейфа float;
- дешевле и предсказуемее на сервере;
- удобно сериализовать в сеть.

### 3) Пакетная обработка партии
Метод `snapshot_party(leader_id, now_ms)` обновляет сразу всех членов партии одним проходом с общим timestamp, что уменьшает накладные расходы.

## Формула расхода
Расход за интервал `dt_ms`:

`loss = (loss_per_minute_milli * dt_ms * activity_multiplier_milli) / (60000 * 1000)`

где `activity_multiplier_milli`:
- 1000 — обычный режим,
- 2000 — двойной расход (спринт/бой),
- 500 — пониженный расход (отдых).

## Расширяемость
Дальше можно добавить:
- дебаффы по порогам (`LOW`, `CRITICAL`, `EMPTY`),
- эффекты климата (жара ускоряет жажду),
- серверные батчи по «грязным» (dirty) партиям для массовых PvE сценариев.
